package il.ac.hit.project.main.viewmodel;

import il.ac.hit.project.main.model.dao.*;
import il.ac.hit.project.main.model.task.*;
import il.ac.hit.project.main.model.report.*;
import il.ac.hit.project.main.view.observable.ObservableProperty;
import il.ac.hit.project.main.viewmodel.combinator.TaskFilters;
import il.ac.hit.project.main.viewmodel.strategy.*;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * ViewModel for the Tasks Management application (MVVM).
 * Bridges between the View (Swing) and the Model/DAO layer:
 * loads tasks, applies filter/sort strategies, exposes observable data to the UI,
 * and delegates persistence operations to the {@link ITasksDAO}.
 * <p>
 * Patterns in use:
 * - Strategy – runtime selection of sorting via {@link ISortingStrategy}.
 * - Combinator – functional composition of predicates for filtering.
 * - Observer – {@link ObservableProperty} notifies the View on changes.
 * - Adapter + Visitor – export via {@link CsvReportAdapter} and {@link ReportVisitor}.
 */
public class TasksViewModel {

    /**
     * Data-access entry (may be proxied/cached depending on {@link DAOFactory} configuration).
     */
    private final ITasksDAO dao = DAOFactory.getInstance().getDAO();

    /**
     * In-memory cache of all tasks retrieved from the DAO (source-of-truth for current session).
     */
    private final List<ITask> all = new ArrayList<>();

    /**
     * Current filter predicate (composed via Combinator helpers). Defaults to "accept all".
     */
    private Predicate<ITask> filter = TaskFilters.any();

    /**
     * Current sorting strategy. Defaults to sort-by-id.
     */
    private ISortingStrategy sort = new SortById();

    /**
     * Observable list of tasks after filter+sort.
     * The View (table model) subscribes to this property to auto-refresh on change.
     * Kept PRIVATE per guideline; expose via getter.
     */
    private final ObservableProperty<List<ITask>> tasks = new ObservableProperty<>(List.of());

    /**
     * Public accessor for the observable tasks property (read-only reference).
     */
    public ObservableProperty<List<ITask>> getTasks() {
        return tasks;
    }

    /**
     * Loads (or reloads) all tasks from the DAO into memory and publishes
     * the filtered+sorted projection to observers.
     */
    public void load() throws TasksDAOException {
        all.clear();
        all.addAll(Arrays.asList(dao.getTasks())); // fetch authoritative list
        publish();                                  // push filtered+sorted view
    }

    /**
     * Sets the active filter predicate; null means "match any". Triggers publish.
     */
    public void setFilter(Predicate<ITask> f) {
        this.filter = (f == null) ? TaskFilters.any() : f;
        publish();
    }

    /**
     * Sets the active sorting strategy; ignores null. Triggers publish.
     */
    public void setSort(ISortingStrategy s) {
        if (s != null) this.sort = s;
        publish();
    }

    /**
     * Applies current filter+sort and notifies observers with a fresh immutable list.
     */
    private void publish() {
        tasks.setValue(
                all.stream()
                        .filter(filter)
                        .sorted(sort.getComparator())
                        .collect(Collectors.toList())
        );
    }

    /**
     * Creates a new task, persists via DAO, then refreshes the view.
     */
    public void add(String title, String desc, TaskState state) throws TasksDAOException {
        dao.addTask(new Task(0, title, desc, state)); // id generated by DAO/DB
        load();
    }

    /**
     * Updates an existing task via DAO, then refreshes the view.
     */
    public void update(ITask t) throws TasksDAOException {
        dao.updateTask(t);
        load();
    }

    /**
     * Deletes a single task by id via DAO, then refreshes the view.
     */
    public void delete(int id) throws TasksDAOException {
        dao.deleteTask(id);
        load();
    }

    /**
     * Exports the currently visible (filtered+sorted) tasks to CSV.
     * Uses {@link ReportVisitor} to build a {@link ReportData} snapshot,
     * then delegates to {@link CsvReportAdapter}.
     */
    public void exportCsv(String path) {
        ReportVisitor v = new ReportVisitor();
        for (ITask t : tasks.getValue()) v.visit(t);
        new CsvReportAdapter().export(v.build(), path);
    }

    /**
     * Deletes all tasks via DAO, then refreshes the view. OR
     * Deletes only the tasks that are currently visible (after filter+sort).
     */
    public void deleteVisible() throws TasksDAOException {
        // tasks.getValue()
        for (ITask t : tasks.getValue()) {
            dao.deleteTask(t.getId());
        }
        load(); // refresh DB
    }
}
